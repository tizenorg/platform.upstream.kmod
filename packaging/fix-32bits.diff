diff --git a/testsuite/init_module.c b/testsuite/init_module.c
index 814998a..ed8b9fc 100644
--- a/testsuite/init_module.c
+++ b/testsuite/init_module.c
@@ -16,6 +16,7 @@
  */
 
 #include <assert.h>
+#include <elf.h>
 #include <errno.h>
 #include <dirent.h>
 #include <fcntl.h>
@@ -206,6 +207,12 @@ static inline bool module_is_inkernel(const char *modname)
 	return ret;
 }
 
+static uint8_t elf_identify(void *mem)
+{
+	uint8_t *p = mem;
+	return p[EI_CLASS];
+}
+
 TS_EXPORT long init_module(void *mem, unsigned long len, const char *args);
 
 /*
@@ -225,6 +232,8 @@ long init_module(void *mem, unsigned long len, const char *args)
 	const void *buf;
 	uint64_t bufsize;
 	int err;
+	uint8_t class;
+	off_t offset;
 
 	init_retcodes();
 
@@ -237,13 +246,20 @@ long init_module(void *mem, unsigned long len, const char *args)
 	kmod_elf_unref(elf);
 
 	/*
-	 * We couldn't find the module's name inside the ELF file. Just exit
-	 * as if it was successful
+	 * We couldn't find the parse the ELF file. Just exit as if it was
+	 * successful
 	 */
 	if (err < 0)
 		return 0;
 
-	modname = (char *)buf + offsetof(struct module, name);
+	/* We need to open both 32 and 64 bits module - hack! */
+	class = elf_identify(mem);
+	if (class == ELFCLASS64)
+		offset = MODULE_NAME_OFFSET_64;
+	else
+		offset = MODULE_NAME_OFFSET_32;
+
+	modname = (char *)buf + offset;
 	mod = find_module(modules, modname);
 	if (mod != NULL) {
 		errno = mod->errcode;
diff --git a/testsuite/stripped-module.h b/testsuite/stripped-module.h
index 9f97dae..19862f3 100644
--- a/testsuite/stripped-module.h
+++ b/testsuite/stripped-module.h
@@ -13,6 +13,7 @@ struct list_head {
 };
 
 #define MODULE_NAME_LEN (64 - sizeof(unsigned long))
+
 struct module
 {
 	enum module_state state;
@@ -24,4 +25,8 @@ struct module
 	char name[MODULE_NAME_LEN];
 };
 
+/*                                padding */
+#define MODULE_NAME_OFFSET_64 4 + 4           + 2 * 8
+#define MODULE_NAME_OFFSET_32 4 + 2 * 4
+
 #endif
